---
title: 'Generic'
layout: post
categories: kotlin
---

## Generic
클래스와 인터페이스의 매개변수 또는 함수의 매개변수와 반환 타입을 미리 확정하지 
않고 정의한 후에 사용되는 시점에서 특정 타입을 지정할 수 있도록 해주는 기법

## 제네릭 클래스의 인스턴스 타입
원시 타입과 제네릭 타입이 결합된 것이 자신의 타입이 된다.
```kotlin
// List<Int> 타입
val listOfInts: List<Int> = listOf(1, 2, 3)

// List<Room> 타입
val listOfRooms: List<Room> = listOf(Room("room1"), Room("room2"))
```

## 제네릭 타입 매개변수의 표준 명칭
- E: 컬렉션에 저장되는 요소(Entity)
- K: 키, Map<K, V>
- V: 값
- N: 숫자 타입
- T: 모든 타입, 기본적으로 Any?를 의미한다.
- R: 함수의 반환값을 나타낸다.

## 제네릭 타입 정의 및 사용
Generic 클래스 생성하기
```kotlin
class LootBox<T>(item: T) {
    private var loot: T = item
}

class Fedora(val name: String, val value: Int)

class Coin(val value: Int)

fun main(args: Array<String>) {
    val lootBoxOne: LootBox<Fedora> = LootBox(Fedora("평범한 중절모", 15))
    val lootBoxTwo: LootBox<Coin> = LootBox(Coin(15))
}
```   
Generic을 사용해서 서로 다른 타입의 인스턴스를 갖는 LootBox 인스턴스를 생성한다.

## 제네릭 함수
```kotlin
class LootBox<T>(item: T) {
    var open = false
    private var loot: T = item
    
    fun fetch(): T? {
        return loot.takeIf { open }
    }
}

fun main(args: Array<String>) {
    val lootBoxOne: LootBox<Fedora> = LootBox(Fedora("평범한 중절모", 15))
    val lootBoxTwo: LootBox<Coin> = LootBox(Coin(15))

    lootBoxOne.open = true
    lootBoxOne.fetch()?.run {
        println("$name 를 LootBox에서 꺼냈습니다.")
    }   
}
```

## 복합 제네릭 타입 매개변수
제네릭 함수나 타입의 매개변수에는 또 다른 제네릭 타입 매개변수를 사용할 수도 있다.  

```kotlin
class LootBox<T>(item: T) {
    var open = false
    private var loot: T = item

    fun fetch(): T? {
        return loot.takeIf { open }
    }

    fun <R> fetch(lootModFunction: (T) -> R): R? {
        return lootModFunction(loot).takeIf { open }
    }
}

fun main(args: Array<String>) {
    val lootBoxOne: LootBox<Fedora> = LootBox(Fedora("평범한 중절모", 15))
    val lootBoxTwo: LootBox<Coin> = LootBox(Coin(15))

    lootBoxOne.open = true
    lootBoxOne.fetch()?.run {
        println("$name 를 LootBox에서 꺼냈습니다.")
    }

    val coin = lootBoxOne.fetch {
        Coin(it.value * 3)
    }
    coin?.let { println(it.value) }
}
```

## 제네릭 타입 제약
Loot의 서브클래스만 LootBox 클래스의 매개변수 타입으로 사용할 수 있다.
```kotlin
class LootBox<T: Loot>(item: T) {
    var open = false
    private var loot: T = item

    fun fetch(): T? {
        return loot.takeIf { open }
    }

    fun <R> fetch(lootModFunction: (T) -> R): R? {
        return lootModFunction(loot).takeIf { open }
    }
}

open class Loot(val value: Int)

class Fedora(val name: String, value: Int): Loot(value)

class Coin(value: Int): Loot(value)
```

## Reference
- [빅 너드 랜치의 코틀린 프로그래밍](http://www.yes24.com/Product/Goods/70968413?OzSrank=17)
